## 자바 프로그래밍
모든 버전의 공통분모인 자바 프로그래밍   
자바 프로그래밍은 모든 자바 버전과 별개의 의미를 갖는다.   
또한 *자바를 이용* 해서 *컴퓨터 프로그램을 만드는 방법*을 의미한다.  
<img src="https://user-images.githubusercontent.com/88714716/180596499-33ea3128-add1-4126-a318-d976452b9133.png" width="400" height="250"><img>   
<img src="https://user-images.githubusercontent.com/88714716/180596550-f35f6149-fee1-480c-b1e1-01b6a1aef274.png" width="400" height="250"><img>   
순차적으로 개발하면서 각 단계의 필요성을 느끼면서 다음 단계로 넘어간다.   
이를 명확히 인지하고 만들어본다.

## OpenJDK 설치하기
자바의 컴파일러는 두 가지 버전이 존재.   
ORACLE(유료화 됨), OpenJDK(무료) 두 가지 존재.   
각 사이트에서 버전에 맞는 JDK 설치하면 됨

## 자바를 이용해서 컴퓨터 프로그램 만들기
### 자바 코드 작성시 기본 규칙
1. 자바에서는 ;을 기준으로 문장을 구분한다.
2. 컴파일러가 알 수 없는 기호들은 변수로 선언해 준다. 변수는 **데이터 타입과 변수명;** 형식으로 한다.
<img src="https://user-images.githubusercontent.com/88714716/180597325-82af082f-2ce8-4432-a052-2a792c83eb80.png" width="400" height="250"><img> 
4. 콘솔 출력 API함수를 사용한다.   
<img src="https://user-images.githubusercontent.com/88714716/180597380-df4114b6-f43d-4ae1-aa88-2c1a9b127037.png" width="400" height="250"><img>
6. 코드의 영역을 나누는 함수블록을 제대로 작성해야 한다.      
<img src="https://user-images.githubusercontent.com/88714716/180597430-f4f2ba19-0233-469b-ab07-a87ebb3a9746.png" width="400" height="250"><img>      
<img src="https://user-images.githubusercontent.com/88714716/180597446-3faa1041-aab9-4433-9f4f-52a46894e47e.png" width="400" height="250"><img>    

## 이클립스 사용하기
Java와 Java EE는 개발할 수 있는 것들이 다르다.   
Java 프로그램을 개발하기 위해서는 Java 환경에서 Java Project를 만든다.   
Java Project 폴더는 우리가 자바 개발을할때 필요한 요소들을 직접 만들지 않아도 실행할 수 있도록 필요한 요소들을 계층구조까지 잡아서 만들어준다.   
Project 폴더를 만든 후 그 안에 src 폴더에 우리가 만들 자바 프로그램 코드를 입력할 .java 파일을 만든다.   
작성한 코드는 식별하기 좋게 방식으로 잘 정리하는 것이 좋은 코드이다.

### shell을 이용해 JAVA 프로그램 실행
1. 메모장에서 JAVA 규칙에 맞는 코드를 작성한 후 클래스이름.java 형식으로 저장.
2. 각 운영체제에 맞는 shell을 실행 시킨 후 javac파일이 설치되어 있는 디렉토리를 찾아 들어간다.
3. 쉘을 통해 javac파일이 존재하는 디렉토리에 들어간 후 'javac 클래스이름.java'로 컴파일 실행.
4. 컴파일 완료되면 같은 디렉토리 내에 클래스이름.class 파일이 생성됨.
5. 'java 클래스이름.class'을 명령어로 입력하면 해당 파일안의 자바코드가 실행됨.   

이 과정에서 shell을 종료 후 다시 시작할때마다 해당 디렉토리에 들어가는 과정부터 시작해야 한다.   
과정을 단축하기위해 해당 디렉토리 주소를 "환경변수"에 설정해서 사용하는 방법을 사용한다.   
환경변수에 넣어서 사용하면 shell 시작 후 디렉토리 변경없이 바로 사용할 수 있다.   
   
shell을 이용해 실행하게되면 코드를 수정할때마다 .java파일에서부터 실행하는 과정을 반복해야한다.   
무수히 많은 프로그램을 반복시키기 위한 방법으로는 상당히 비효율적이다.

## 자바 IDE 설치하기
개발하기 위해서는 텍스트 편집기 + shell(컴파일, 실행) + 탐색기(파일위치 검색)이 필요하다.   
프로그램을 실행하기 위해 번갈아가면서 사용하는 것은 상당히 번거롭기 때문에 이를 통합한 통합개발환경(IDE)가 등장하게 되었다.   
<img src="https://user-images.githubusercontent.com/88714716/180597611-174a1ccf-7feb-48a7-84cc-bc74cf7ada90.png" width="400" height="250"><img>   
IBM에서 JAVA의 개발환경을 통합하기 위해 개발하던 중 모든 언어의 개발환경에 위 요소들이 동일하게 필요하다는 것을 알았고,   
컴파일러만 다르게 바꾸면 다른 언어의 개발환경도 통합이 가능하다는 것을 알았다.   
<img src="https://user-images.githubusercontent.com/88714716/180597629-6bc57597-bfd9-44ca-a4d7-fbcb6d06f59e.png" width="300" height="200"><img>   
<JAVA 개발환경>   
<img src="https://user-images.githubusercontent.com/88714716/180597644-0c56762c-2aa9-4611-8734-38840d9461ca.png" width="300" height="200"><img>   
<C++ 개발환경>   
해당 그림에서 워크벤치(WorkBench) 자체만으로는 IDE가 될 수 없다. 각 언어의 컴파일러와 같은 다른 요소들이 결합해야 완성된다.   
이클립스가 IBM에서 만든 IDE이다.   
이클립스에서는 JAVA, C, C++, Mobile 등 개발할 것에 따라 다르게 다운받아 사용하면 된다. 

### 자주사용하는 단축키
ctrl + shift + f : 코드 들여쓰기   
shift + tab : 코드 내어쓰기   
command + 화살표 : 코드라인 이동

## 자바 언어의 특징
미국에서 처음으로 가전제품에서 양방향 소통을 하기위한 프로그램을 만들기 위한 팀이 생성됨.   
프로젝트를 맡은 팀에서는 처음 C++로 진행하려했지만, 여러 문제가 있다고 생각하게 되었음. 이때 새로운 언어의 필요성을 느끼게 되었다.   
   
### C/C++이 가지는 문제점은 무엇?
- 객체의 생성과 제거를 모두 사람이 하다보니 쌍으로 이뤄지지 않은 경우가 발생했음. 제거가 되지 않은 객체가 메모리상에 존재하게 되었음.    
메모리 누수 현상이 발생함. 삭제되지 않은 객체 때문에 메모리 부족현상이 발생하게 되었음.   
→ delete 키워드를 제거해서 객체를 생성만 할 수 있게하고 제거는 할 수 없게 했다. Java 실행환경이 알아서 자동으로 지워주는 방식

- 참조변수와 포인터 변수가 존재했다   
→ 포인터 변수를 제거하고 참조변수만 남게했다. 객체의 포인터 제거.   

- 이차 이상의 포인터 문제   
→ 모든 포인터를 제거함

- 데이터 구조를 정의하는 두 가지 방법(struct, class)   
→ struct 키워드를 제거. 한가지 방법만 사용하도록 함

- 함수지향? 객체지향? (C++은 둘 다 지원했음)   
→ 함수는 메서드로만 사용하도록 제약함. 완전한 객체지향 언어로 사용하도록.

- 컬렉션의 부재(외부 라이브러리 사용)   
→ 언어에 컬렉션을 포함

- 글로벌한 문자 데이터처리의 복잡성   
→ 다양한 인코딩 문자열 기능 개선
   
- …. → …제거 
- C/C++에서 기능 대부분 제거되었음. 그리고 컬렉션은 포함되었다.   

<img src="https://user-images.githubusercontent.com/88714716/180598000-512fb7ab-c7f7-4429-af06-be77aa6da26a.png" width="400" height="250"><img>   
<C++과 비교했을때의 초기 특징>

## 자바 플랫폼의 특징
- 새로운 WORA(Write Once Run Anywhere)을 추구했음.   
- 플랫폼에 의존적   
<img src="https://user-images.githubusercontent.com/88714716/180598171-dd92bec6-b730-44d9-92a1-e3f9f72eec4f.png" width="400" height="250"><img>   
각기 다른 운영체제에 동일한 자바플랫폼을 설치하면 단일화된 javaAPI를 사용할 수 있도록 제작했다.   
   
단점   
1. 자바 플랫폼을 설치하지 않으면 사용할 수 없다.
2. 각 운영체제가 갖고있는 특징을 살릴 수 없다.

## 자바 번역기의 특징
WORA를 지원하기 위해 자바 코드를 만들고, 플랫폼을 통해 javaAPI를 맞춰놓았다.   
하지만 API가 문제가 아니라, 코드 자체가 실행이 안될 수 있는 문제가 발생했다.   
<img src="https://user-images.githubusercontent.com/88714716/180646322-2a0f13c3-e418-4806-91ab-837bb91214eb.png" width="500" height="300"><img>   

### why?
원래 자바 소스코드에 번역기를 두 번 돌려서 CPU가 이해할 수 있는 기계(이진)코드로 전환했다.   
하지만 만들어진 CPU에서만 작동되도록 만들어져 CPU의 종류에 따라 다른 기계코드가 필요하게 되었다.  
   
예를 들어, intel에서 만든 CPU에 돌아가는 코드는 ARM에서 만든 CPU에서는 작동하지 않는 문제가 발생했다.   
   
그러면 이때 번역과정에 대해 다시 생각해볼 필요가 있었다.   
번역을 해야하는가? 어떻게 번역을 해야하는가?   
   
자바코드의 번역과정을 우선 살펴보면   
<img src="https://user-images.githubusercontent.com/88714716/180646393-648da4b6-f40c-4c6f-a9e9-6e8179797de4.png" width="600" height="200"><img>   
위 그림과 같이 1~6단계로 이루어져있다. 위 과정을 나누어 문제를 해결하기 위해 컴파일러를 사용해 4단계까지 번역한 후, 5,6단계는 해당 CPU에 가서 번역하는 방법을 고안해냈다.   
이에 따라 컴파일러는 주로 번역을 하고, 인터프리터는 실행을 위주로 하지만 필요에 따라서 번역하는 과정도 가지게되었다.   
   
<img src="https://user-images.githubusercontent.com/88714716/180646442-d1a40f24-d0a6-4904-9a1d-54019a51c9d3.png" width="400" height="250"><img>   
이러한 과정을 통해 새로운 중간코드가 만들어지게 되었다.   
중간 코드는 자바소스 코드를 컴파일 될 수 있도록 저급언어로 바꾸는 과정이다.   
실제로 중간코드가 물리장치를 실행할 수 있는 건 아니지만 가상의 CPU를 염두해두고 번역을 한다.   
이때 중간코드는 같은의미인 다른 언어들로 불릴 수 있다.   
중간 코드   
= 바이트 코드(각각을 이루는 명령어들이 1byte 코드로 이루어졌기 때문)   
= 가상 CPU 코드   
= 의사코드   
= 슈도코드(pseducode), 의사 코드는 실제로 물리장치를 실행할 수 있는 건 아니지만 어떤 방법으로 물리코드를 만들겠다고 염두해놓은 코드들을 의미한다.   
   
<img src="https://user-images.githubusercontent.com/88714716/180646467-8e171578-9641-42e0-a09c-8abf47f433d2.png" width="500" height="300"><img>   
중간코드를 도입하는 방법으로 최종적으로 위와 같은 그림으로 해결방법을 찾게되었다.   
JDK는 컴파일러와 디버거 등 개발자에게 필요한 도구들로 구성되어 있다.   
JRE는 자바가 실행 될 수 있는 환경에 필요한 것들이다, 보통 JDK를 설치하게 되면 자동으로 설치가 된다.   
이때 인터프리터를 다른 말로 JIT(Just In Time)컴파일러라고 한다.   
   
자바프로그램이 실행되는 과정을 정리해보자.   
자바 소스코드를 Compiler로 컴파일하게 되면 .class 파일이 생성된다. 이 파일은 바이트코드이다. 이 클래스확장자 파일을 적재하고(Loader), 보안 검사 후(Security), 실행시키고 (JIT(Just In Time)컴파일러) 메모리에 필요없어진 내용들을 제거해주는(Garbage Collector) 기능들을 가진 환경(JRE)에서 실행되게 된다. 

## 값의 종류와 표현방법(in Java)
- 정수값   
   2진수, 8진수, 10진수, 16진수로 표현할 수 있음.   
   ex) 0b11010(2진수), 032(8진수), 26(10진수), 0x1a(16진수)   
   Java에서는 32bit(= 4byte)까지의 정수까지 밖에 표현할 수 없음.   
   4byte이상의 수를 표현할때 L을 붙인다 이렇게 되면 8byte까지 표현할 수 있다. 
- 실수값   
   123.4 = 123.4d(8 byte code, 기본형, d를 붙여도되고 붙이지 않아도 됨), 123.4f(4 byte code).  
   실수는 진법을 사용하지 않는다.   
   실수의 범위는 접미사 f, d에 따라 다르다.   
   지수법을 사용해 표기법을 달리 할 수도 있다.   
   ex) 123.4 = 1.234e2(소수점이 앞으로 이동한 숫자만큼 e 뒤에 적어준다. 뒤로가는 경우는 따로 있음.)   
   지수법을 사용해도 d or f를 이용해서 데이터 범위를 다르게 나타낼 수 도 있음.    
- 문자값   
   'A'와 같이 ''(작은 따옴표)로 감싸주어야 한다.   
   'A' = ‘₩u0065’ 문자값을 코드값으로 표현도 가능하다.   
- 진리(논리)값     
   true, false
   
## 값의 진법 변환
2진수 → 오른쪽부터 n 자리수는 2의 n 제곱을 의미한다.(n은 0부터 시작한다)   
8진수 →  10진수를 2진수로 변환한 뒤 오른쪽부터 3개씩 묶어서 읽으면 된다.   
16진수 → 0~9,A~F → 0~15까지의 숫자를 의미함. 대소문자를 가리지 않음. 10진수를 2진수로 변환한 뒤 오른쪽부터 4개씩 읽으면된다.   
<img src="" width="500" height="300"><img>   
<소수점 이진수의 십진수로 변환>

## 값의 형식과 변환
<img src="https://user-images.githubusercontent.com/88714716/180647285-8695933e-d3b6-411e-989f-b6ddc2bd4c31.png" width="500" height="300"><img>   
값의 형식은 정수형, 실수형, 문자형, 논리형으로 나눌 수 있다.   
이때 정수형의 기본형은 int이고, 실수형의 기본형은 double이다.   
   
값의 형식을 변환할때는 2가지형식 변환이 발생할 수 있다.   
1. 묵시적 형변환
2. 암시적 형변환.  
      
묵시적 형변환은 선언된 변수의 데이터 타입보다 대입되는 데이터의 타입이 작은 경우 자동적으로 발생하는 경우이다.   
형변환을 명시하지 않아도 되지만 명시하고 싶으면 해도 된다.   
ex) long x = 30; (o)   
ex) long x = (long)30; (o)   

암시적 형변환은 선언된 변수의 데이터타입이 대입되는 데이터의 타입보다 큰 경우 데이터의 손실이 발생될 수 있어 컴파일 오류가 발생한다.   
하지만 사용자가 이를 인지하고 데이터의 손실이 있더라도 형식을 바꾸고 싶을 때 사용하는 방법이다.   
ex) byte x = 30; (x).  
ex) byte x = (byte) 30; (o).  

## 정수 값의 크기와 범위
<img src="https://user-images.githubusercontent.com/88714716/180647440-6a91cb3f-03cc-482b-b8af-7c29a4f9806b.png" width="500" height="300"><img>   
bit당 표현할 수 있는 경우의 수는 2가지이다. 그러므로 bit가 추가될때 마다 2를 곱해준다.  
1byte = 8bit이므로 1byte가 표현할 수 있는 경우의 수는 256가지이다.   
이때 정수값은 음수도 포함되므로 맨 앞 비트를 부호비트로 설정하고 나머지 7bit를 값의 범위로 지정해 준다.

## 부동 소수점(Float Point)실수의 크기와 범위
<img src="https://user-images.githubusercontent.com/88714716/180647848-d477f566-2df1-4f8e-8ce2-a5e26d5660d7.png" width="400" height="300"><img>   
<img src="https://user-images.githubusercontent.com/88714716/180647879-35ce1bbe-22d1-400b-a218-86805b5a86a5.png" width="500" height="300"><img>   
고정 소수점은 위와 같이 정수부와 소수부로 구분되어 있다. 정수부에서 부호비트를 내어준다.   
고정 소수점의 단점은 값을 표현할 때 유연하지 못하다는 단점이있다.   
<img src="https://user-images.githubusercontent.com/88714716/180647901-f738fa01-a42e-4ffe-aa3b-6ce73c851fea.png" width="500" height="300"><img>  
위와 같이 값을 표현할때 정해진 구역만 사용해서 값을 표현하기 때문에 정수의 값이 커지면서 정수부로 표현 될 수 있는 범위를 넘어서도 사용하지 않는 소수부 부분을 활용하지 못한다.   
이러한 단점을 보완하기 위해 부동 소수점이 나타나게 되었다.   
부동 소수점은 값을 표현할 때 지수부와 가수부로 나누어 데이터의 공간을 좀 더 효율적으로 사용할 수 있게 되었다.   
   
<img src="" width="500" height="300"><img>   
<img src="" width="500" height="300"><img>   
<img src="" width="500" height="300"><img>   

